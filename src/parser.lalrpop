use std::str::FromStr;
use std::collections::HashMap;
use lalrpop_util::ParseError;
use iro::ast::*;
use iro::lexer;
use iro::types::types::TypeInfo;

grammar;

pub Top : Program = {
    NL* <TopLevelExpr*> => Program{ exprs: <> },
};

#[inline]
Comma<T>: Vec<T> = {
    <items: (<T> ",")*> <last: T?> => {
        let mut items = items;
        items.extend(last);
        items
    }
};

// Expressions
Expr = <StandaloneExpr> NL+;
TopLevelExpr = {
    <DefStatement> NL+,
    <Expr>,
};
StandaloneExpr = ReturnExpr;

// Function definitions
DefStatement: NodeBox = {
    "def" <id:Identifier> "(" <aargs:Comma<DefArgument>> ")" NL+ <exprs:Expr*> "end" =>? {
        let mut args = HashMap::new();
        for (id, val) in aargs {
            if let Some(_) = args.insert(id, val) {
                return Err(ParseError::User { error: lexer::Error::DuplicateArguments });
            }
        }
        Ok(NodeBox::new(DefStatement { id, args, exprs }))
    },
    "def" <id:Identifier> NL+ <exprs:Expr*> "end" => {
        NodeBox::new(DefStatement { id, args : HashMap::new(), exprs })
    },
};

DefArgument: (String, Option<NodeBox>) = {
    <id:Identifier> => {
        (id, None)
    },
    <id:Identifier> ":" <ty:Type> => {
        (id, Some(ty))
    },
};

// Return expression
ReturnExpr: NodeBox = {
    "return" <expr:StandaloneExpr> => {
        NodeBox::new(ReturnExpr { expr })
    },
    IfExpr,
};

// If expression
IfExpr: NodeBox = {
    "if" <cond:StandaloneExpr> NL+ <exprs:Expr*> "else" NL+ <elses:Expr*> "end" => {
        NodeBox::new(IfExpr { cond, exprs, elses })
    },
    "if" <cond:StandaloneExpr> NL+ <exprs:Expr*> "end" => {
        NodeBox::new(IfExpr { cond, exprs, elses: vec![] })
    },
    CallExpr,
};

// Call expression
CallExpr: NodeBox = {
    <callee:BinExpr> "(" <args:Comma<StandaloneExpr>> ")" => {
        NodeBox::new(CallExpr { callee, args })
    },
    BinExpr,
};

// Binary expressions
BinOpTier<Op,NextTier>: NodeBox = {
    <left:BinOpTier<Op,NextTier>> <op:Op> <right:NextTier> => NodeBox::new(BinExpr{ left, right, op }),
    NextTier
};

BinExpr = AsgExpr;
AsgExpr = BinOpTier<AsgOp, AndExpr>;
AndExpr = BinOpTier<AndOp, OrzExpr>;
OrzExpr = BinOpTier<OrzOp, CmpExpr>;
CmpExpr = BinOpTier<CmpOp, AddExpr>;
AddExpr = BinOpTier<AddOp, FacExpr>;
FacExpr = BinOpTier<FacOp, Term>;

AsgOp: BinOp = {
    "=" => BinOp::Asg,
    "+=" => BinOp::Adds,
    "-=" => BinOp::Subs,
    "*=" => BinOp::Muls,
    "/=" => BinOp::Divs,
};

AndOp: BinOp = {
    "and" => BinOp::And,
};

OrzOp: BinOp = {
    "or" => BinOp::Or,
};

CmpOp: BinOp = {
    "==" => BinOp::Equ,
    "!=" => BinOp::Neq,
};

AddOp: BinOp = {
    "+" => BinOp::Add,
    "-" => BinOp::Sub,
};

FacOp: BinOp = {
    "*" => BinOp::Mul,
    "/" => BinOp::Div,
};

// Literals / terms
Term: NodeBox = {
    <Literal> => NodeBox::new(<>),
    "(" <Expr> ")" => <>,
};

Literal: Value = {
    <Int> => Value::Integer(<>),
    <String> => Value::String(<>),
    <Identifier> => Value::Identifier(<>),
};

// Types
Type: NodeBox = {
    <Identifier> => NodeBox::new(Value::Identifier(<>)),
};


// Hook external lexer:
extern {
    type Location = usize;
    type Error = lexer::Error;

    enum lexer::Tok {
        "def" => lexer::Tok::Def,
        "return" => lexer::Tok::Return,
        "if" => lexer::Tok::If,
        "else" => lexer::Tok::Else,
        "end" => lexer::Tok::End,
        "and" => lexer::Tok::And,
        "or" => lexer::Tok::Or,
        "==" => lexer::Tok::Equ,
        "!=" => lexer::Tok::Neq,
        "+" => lexer::Tok::Add,
        "-" => lexer::Tok::Sub,
        "*" => lexer::Tok::Mul,
        "/" => lexer::Tok::Div,
        "=" => lexer::Tok::Asg,
        "+=" => lexer::Tok::Adds,
        "-=" => lexer::Tok::Subs,
        "*=" => lexer::Tok::Muls,
        "/=" => lexer::Tok::Divs,
        "(" => lexer::Tok::LeftParen,
        ")" => lexer::Tok::RightParen,
        "," => lexer::Tok::Comma,
        ":" => lexer::Tok::Colon,
        NL => lexer::Tok::Newline,
        Int => lexer::Tok::Int { value : <i64> },
        Identifier => lexer::Tok::Identifier { value : <String> },
        String => lexer::Tok::String { value : <String> },
    }
}